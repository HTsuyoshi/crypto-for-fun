

# This file was *autogenerated* from the file RSA.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1024 = Integer(1024); _sage_const_1000 = Integer(1000); _sage_const_1 = Integer(1)
from sage.all import *

KEY_SIZE = _sage_const_2 **(_sage_const_1024 )
print(KEY_SIZE)
OFFSET = _sage_const_1000 

# RSA
def RSA(m: int, e: int, n: int) -> int:
    ring = Integers(n)
    c = ring(m) ** e
    return c

if __name__ == '__main__':

    m = input('Write your message here: ').encode()
    m = int.from_bytes(m, byteorder='little')
    print(f'm as int: {m}')

    p = random_prime(n = KEY_SIZE*OFFSET, lbound = KEY_SIZE)
    q = random_prime(n = KEY_SIZE*OFFSET, lbound = KEY_SIZE)
    print(f'p = {p}, q = {q}')

    n = p * q
    print(f'n = {n}')

    def euler_func(q, p):
        return (q-_sage_const_1 ) * (p-_sage_const_1 )

    phi = euler_func(q, p)
    print(f'phi = (q-1)*(r-1) = {q - _sage_const_1 } x {r - _sage_const_1 } = {phi}\n')

    try:
        d = pow(m, -_sage_const_1 , phi)
    except ZeroDivisionError:
        print(f'The message doesn\'t have an inverse')
        exit(_sage_const_1 )

    ring = Integers(n)
    p = ring(p)
    print(f'm = {m}, p = {p}, m*p = {p * m} mod {n}\n')

    # Ex 6
    ring = Integers(phi)
    p = pow(m, -_sage_const_1 , phi)
    print(f'm = {m}, p = {p}, m*p = {p * m} mod {phi}\n')
    assert p * m == _sage_const_1 

    c = RSA(m, p, n)
    print(f'c = {c}\n')

    # Ex 10
    m = RSA(c , d, n)
    print(f'm = {m}\n')
    assert c == m, f'Inverse doesn\'t match'

